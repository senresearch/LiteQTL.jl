var documenterSearchIndex = {"docs":
[{"location":"library/#Library-1","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [LiteQTL]","category":"page"},{"location":"library/#LiteQTL.get_geno_data-Tuple{Any,Any}","page":"Library","title":"LiteQTL.get_geno_data","text":"get_geno_data(file, datatype)\n\n\nreturns the genotype data. Will skip every other column because genotype probability is duplicated. \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.get_pheno_data-Tuple{Any,Any}","page":"Library","title":"LiteQTL.get_pheno_data","text":"get_pheno_data(file, datatype; transposed)\n\n\nreturns the phenotype data. If transposed=true, then the data will be transposed. \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.scan","page":"Library","title":"LiteQTL.scan","text":"scan(Y, G)\nscan(Y, G, X; maf_threshold, export_matrix, usegpu, lod_or_pval, timing_file)\n\n\nThis function is the main API for eQTL scans. EQTL scan process includes     If no covariate:      - filter maf if the threshold is greater than 0     - standardizing phenotype matrix (Y) and genotype matrix (G)     - calculate correlation (R) matrix.      - computes log of odds (LOD) score matrix, or p-value if lod_or_pval is set to lod     - calculate maximum LOD score if export_matrix is set to false. \n\nIf covariates exists:\n- calculate px \n- computes Y hat and G hat by matrix multiplication. \n- substract Y hat and G hat from Y and G respectively. \n- filter maf if the threshold is greater than 0\n- standardizing phenotype matrix (Y) and genotype matrix (G)\n- calculate correlation (R) matrix. \n- computes log of odds (LOD) score matrix, or p-value if `lod_or_pval` is set to `lod`\n- calculate maximum LOD score if `export_matrix` is set to false.\n\nArguments:\n\nY : a matrix of phenotypes.\nG : a matrix of genotypes.\nX : a matrix of covariates. Default is nothing. If nothing, scan is run without covariates. \nmaf_threshold: a floating point number to indicate the maf_threshold. Default is 0.05. Set to 0 if no maf filtering should be done. \nexport_matrix : a boolean value that determines whether the result should be the maximum value of LOD score of each phenotype and its corresponding index, or the whole LOD score matrix. \nusegpu : a boolean value that indicates whether to run scan function on GPU or CPU. Default is false, which runs scan on CPU. \nlod_or_pval: a string value of either lod or pval to indicate the desired output. \ntiming_file: a string that indicates the file location for the timing outputs. Default is nothing. \n\nOutput:\n\nreturns LOD score or pval, in vector or matrix format depending on value of export_matrix. \n\n\n\n\n\n","category":"function"},{"location":"library/#LiteQTL.calculate_nr-Tuple{AbstractArray{var\"#s32\",2} where var\"#s32\"<:Real,AbstractArray{var\"#s31\",2} where var\"#s31\"<:Real}","page":"Library","title":"LiteQTL.calculate_nr","text":"calculate_nr(a, b)\n\n\nComputes correlation matrix (R) * n. n is not removed because of performance choice. \n\nArguments\n\na : standardized phenotype matrix\nb : standardized genotype matrix\n\nOutput:\n\nreturns correlation matrix R \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.calculate_nr-Tuple{CUDA.CuArray,CUDA.CuArray}","page":"Library","title":"LiteQTL.calculate_nr","text":"calculate_nr(a, b)\n\n\nComputes correlation matrix (R) * n on GPU with cuBLAS library. n is not removed because of performance choice. \n\nArguments\n\na : standardized phenotype matrix\nb : standardized genotype matrix\n\nOutput:\n\nreturns correlation matrix R on GPU device (of type CuArray). \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.calculate_px-Tuple{AbstractArray{var\"#s33\",2} where var\"#s33\"<:Real}","page":"Library","title":"LiteQTL.calculate_px","text":"calculate_px(x)\n\n\nArguments\n\nx : input matrix\n\nOutput:\n\nreturns px\n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.cpurun","page":"Library","title":"LiteQTL.cpurun","text":"cpurun(pheno, geno)\ncpurun(pheno, geno, X; maf_threshold, export_matrix, lod_or_pval, timing_file)\n\n\nArguments:\n\nY : a matrix of phenotypes.\nG : a matrix of genotypes.\nX : a matrix of covariates. Default is nothing. If nothing, scan is run without covariates. \nmaf_threshold: a floating point number to indicate the maf_threshold. Default is 0.05. Set to 0 if no maf filtering should be done. \nexport_matrix : a boolean value that determines whether the result should be the maximum value of LOD score of each phenotype and its corresponding index, or the whole LOD score matrix. \nlod_or_pval: a string value of either lod or pval to indicate the desired output. \ntiming_file: a string that indicates the file location for the timing outputs. Default is nothing. \n\nOutput:\n\nreturns LOD score or pval, in vector or matrix format depending on value of export_matrix. \n\n\n\n\n\n","category":"function"},{"location":"library/#LiteQTL.filter_maf-Tuple{Array{var\"#s30\",2} where var\"#s30\"<:Real}","page":"Library","title":"LiteQTL.filter_maf","text":"filter_maf(genotype; maf_threshold)\n\n\nFilter genotype data with a minor allele frequency threshold. \n\nArguments\n\ngenotype : genotype matrix\nmaf_threshold : default value is 0.05. \n\nOutput:\n\nreturns filtered genotype matrix. \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.find_max_idx_value-Tuple{AbstractArray{var\"#s30\",2} where var\"#s30\"<:Real}","page":"Library","title":"LiteQTL.find_max_idx_value","text":"find_max_idx_value(lod)\n\n\nComputes the index of maximum, and maximum value of each row of a matrix.  Optimized with multi-threading. \n\n!Notes: Set the thread number with env JULIANUMTHREADS to your desired number of threads.  For example: JULIA_NUM_THREADS=16 julia\n\nArguments\n\nlod : input matrix. \n\nOutput:\n\nreturns a matrix with two columns, first column is the index of maximum, second column is  the maximum value. \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.get_pheno_block_size-Tuple{Int64,Int64,Int64,DataType}","page":"Library","title":"LiteQTL.get_pheno_block_size","text":"get_pheno_block_size(n, m, p, datatype)\n\n\nComputes the number of blocks for chuncking large phenotype matrix, to fit into GPU memory. \n\nArguments\n\nn : number of individuals\nm : number of phenotypes \np : number of genotype markers\ndatatype: datatype of phenotype. (Float32, or Float64)\n\nOutput:\n\nreturns\n\nnum_block : number of blocks to disect phenotype\nblock_size : size of each block. \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.get_standardized_matrix-Tuple{AbstractArray{var\"#s33\",2} where var\"#s33\"<:Real}","page":"Library","title":"LiteQTL.get_standardized_matrix","text":"get_standardized_matrix(mat)\n\n\nComputes standardized matrix on CPU utilizing multi-threads. \n\nArguments\n\nm : a matrix to be standardized\n\nOutput:\n\nreturns the standardized matrix of m\n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.get_standardized_matrix_gpu-Tuple{AbstractArray{var\"#s13\",2} where var\"#s13\"<:Real}","page":"Library","title":"LiteQTL.get_standardized_matrix_gpu","text":"get_standardized_matrix_gpu(m)\n\n\nComputes standardized matrix on GPU. Theoretically this function  works with CPU as well. But it is not as fast as the  get_standardized_matrix function, which utilizes multi threads on CPU. \n\nArguments\n\nm : a matrix to be standardized\n\nOutput:\n\nreturns the standardized matrix of m\n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.gpu_square_lod-Tuple{CUDA.CuArray{var\"#s144\",2} where var\"#s144\"<:Real,Any,Any,Any,Bool}","page":"Library","title":"LiteQTL.gpu_square_lod","text":"gpu_square_lod(d_nr, n, m, p, export_matrix)\n\n\nSets up GPU environment and calls GPU kernels. \n\nArguments\n\nd_nr : Output matrix (correlation matrix) in CuArray format\nn : number of individuals\nm : number of phenotypes \np : number of genotype markers\nexport_matrix : boolean value to indicate user desire output\n\nOutput:\n\nreturns correlation matrix R, or maximum of R if export_matrix is set to false\n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.gpurun","page":"Library","title":"LiteQTL.gpurun","text":"gpurun(pheno, geno)\ngpurun(pheno, geno, X; maf_threshold, export_matrix, timing_file)\n\n\nArguments:\n\nY : a matrix of phenotypes.\nG : a matrix of genotypes.\nX : a matrix of covariates. Default is nothing. If nothing, scan is run without covariates. \nmaf_threshold: a floating point number to indicate the maf_threshold. Default is 0.05. Set to 0 if no maf filtering should be done. \nexport_matrix : a boolean value that determines whether the result should be the maximum value of LOD score of each phenotype and its corresponding index, or the whole LOD score matrix. \nlod_or_pval: a string value of either lod or pval to indicate the desired output. \ntiming_file: a string that indicates the file location for the timing outputs. Default is nothing. \n\nOutput:\n\nreturns LOD score, in vector or matrix format depending on value of export_matrix. P value for GPU is not currently implementated. \n\n\n\n\n\n","category":"function"},{"location":"library/#LiteQTL.is_corr_in_range-Tuple{Any,Any,Any}","page":"Library","title":"LiteQTL.is_corr_in_range","text":"is_corr_in_range(r, min, max)\n\n\nChecks whether correlation matrix is in range. Only runs if DEBUG flag is turned on from julia commandline. \n\nArguments\n\nr : a matrix to be standardized\nmin : minimum value of range \nmax : maximum value of range \n\nOutput:\n\nerrors message will show if correlation matrix is not in range. \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.lod2p-Tuple{Any}","page":"Library","title":"LiteQTL.lod2p","text":"lod2p(lod)\n\n\nComputes p-value based on log of odds score. \n\nArguments\n\nlod : LOD matrix\n\nOutput:\n\nreturns p-value. \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.lod_kernel-Tuple{Any,Any,Any}","page":"Library","title":"LiteQTL.lod_kernel","text":"lod_kernel(nr, MAX, n)\n\n\nGPU kernel that computes LOD scores. \n\nArguments\n\nnr : correlation matrix. will be updated with output results. (Type CuArray)\nMAX : number of total GPU threads, also called ndrange. \nn : number of individuals\n\nOutput:\n\nResults written back to input matrix nr. Returns the LOD scores. \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.lod_score_multithread-Tuple{Any,AbstractArray{Float32,2}}","page":"Library","title":"LiteQTL.lod_score_multithread","text":"lod_score_multithread(m, nr)\n\n\nComputes log of odds (LOD) score. Optimized for correlation matrix type is Float32 (single precision).\n\n!Notes: Set the thread number with env JULIANUMTHREADS to your desired number of threads.  For example: JULIA_NUM_THREADS=16 julia\n\nArguments\n\nm : number of individuals. \nnr : correlation matrix R times n. N will be removed during this step. \n\nOutput:\n\nreturns LOD score. \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.lod_score_multithread-Tuple{Any,AbstractArray{Float64,2}}","page":"Library","title":"LiteQTL.lod_score_multithread","text":"lod_score_multithread(m, nr)\n\n\nComputes log of odds (LOD) score. Optimized for correlation matrix type is Float64 (double precision).\n\n!Notes: Set the thread number with env JULIANUMTHREADS to your desired number of threads.  For example: JULIA_NUM_THREADS=16 julia\n\nArguments\n\nm : number of individuals. \nnr : correlation matrix R times n. N will be removed during this step. \n\nOutput:\n\nreturns LOD score. \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.reduce_kernel-Tuple{Any,Any,Any}","page":"Library","title":"LiteQTL.reduce_kernel","text":"reduce_kernel(input, rows, cols)\n\n\nComputes the maximum LOD score of each row. Results written back to the first two columns.\n\nArguments\n\ninput : LOD score\nrows : number of rows for input\ncols : number of cols for input\n\nOutput:\n\nOutput is written to the input matrix, first column of input matrix is the index of maximum, and second column is the maximum value of that row. \n\n\n\n\n\n","category":"method"},{"location":"library/#LiteQTL.set_blas_threads-Tuple{Any}","page":"Library","title":"LiteQTL.set_blas_threads","text":"set_blas_threads(nthread)\n\n\nSets the number of threads that will be used by BLAS library.  !Notes: Set the thread number with env JULIANUMTHREADS to your desired number of threads.  For example: JULIA_NUM_THREADS=16 julia\n\nArguments\n\nnthread : desired number of threads \n\nOutput:\n\nShows number of threads set. \n\n\n\n\n\n","category":"method"},{"location":"#LiteQTL.jl-Documentation-1","page":"Home","title":"LiteQTL.jl Documentation","text":"","category":"section"},{"location":"#Package-information-1","page":"Home","title":"Package information","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"LiteQTL is a package that runs whole genome QTL scans near real-time, utilizing the computation power of GPU. ","category":"page"},{"location":"#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Near real time computation for whole genome scan using Linear Model\nGenome scan with covairates\nCPU parallelization and GPU acceleration\nInput data can be of different precisions (Float32, or Float64)","category":"page"},{"location":"#Input-and-Output-1","page":"Home","title":"Input and Output","text":"","category":"section"},{"location":"#Input-(all-with-no-missing-data)-1","page":"Home","title":"Input (all with no missing data)","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Genotype probability \nPhenotype\nCovariates (Optional)","category":"page"},{"location":"#Output-1","page":"Home","title":"Output","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Default) Maximum LOD (Log of Odds) score, and the index of the maximum\nLOD (Log of Odds) matrix","category":"page"},{"location":"#Example-1","page":"Home","title":"Example","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We have created a Jupyter notebook with the whole analysis pipeline using the BXD spleen data as an example.  Users can run eQTL scans and create a eQTL hits figure.  See: example/spleen_analysis.ipynb","category":"page"},{"location":"#Auxilary-Github-Repositories-1","page":"Home","title":"Auxilary Github Repositories","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"LiteQTL.jl Binary Compilation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This repo contais scripts to compile the LiteQTL package to remove the compilation time of Julia (the extra time in the first run in Julia REPL).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"LiteQTL.jl G3 Journal Supplemental Materials","category":"page"},{"location":"#","page":"Home","title":"Home","text":"It is an effort to make our research reproducible. All code related to experiment reuslt, from dowloading data, cleaning data, to running LiteQTL and creating figure are found in this repository. You can recreate the results in our paper Speeding up eQTL scans in the BXD population using GPUs using the scripts in this repository.","category":"page"},{"location":"#Index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"library.md\"]","category":"page"}]
}
